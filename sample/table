#!/usr/bin/env ruby

require 'table'
require 'optparse'

def main(argv)
  subcommand = argv.shift
  case subcommand
  when 'help' then main_help(argv)
  when 'csv' then main_csv(argv)
  when 'json' then main_json(argv)
  when 'yaml' then main_yaml(argv)
  when 'pp' then main_pp(argv)
  when 'grep' then main_grep(argv)
  when 'sort' then main_sort(argv)
  when 'select' then main_select(argv)
  when 'rename' then main_rename(argv)
  when 'cat' then main_cat(argv)
  when 'join' then main_join(argv)
  when 'count' then main_count(argv)
  when nil
    err "Usage: table subcommand args..."
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

def usage(status)
  print <<'End'
Usage:
  table csv [opts] TABLE
  table json TABLE
  table yaml TABLE
  table pp [opts] TABLE
  table grep [opts] REGEXP TABLE
  table sort [opts] FIELD... TABLE
  table select [opts] FIELD... TABLE
  table rename [opts] SRCFIELD DSTFIELD ... TABLE
  table cat [opts] TABLE...
  table join [opts] TABLE...
  table count [opts] FIELD... COUNT-FIELD TABLE
End
  exit status
end

def main_help(argv)
  subcommand = argv.shift
  case subcommand
  when 'grep' then puts op_grep
  when nil
    usage(true)
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

$opt_n = nil

def op_csv
  op = OptionParser.new
  op.banner = 'Usage: table csv [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_pp
  op = OptionParser.new
  op.banner = 'Usage: table pp [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

$opt_grep_e = nil
$opt_grep_f = nil
$opt_grep_v = nil
def op_grep
  op = OptionParser.new
  op.banner = 'Usage: table grep [options] REGEXP TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-f FIELD') {|field| $opt_grep_f = field }
  op.def_option('-e REGEXP') {|pattern| $opt_grep_e = pattern }
  op.def_option('-v') { $opt_grep_v = true }
  op
end

def err(msg)
  STDERR.puts msg
  exit 1
end

def main_csv(argv)
  op_csv.parse!(argv)
  each_table_file(argv) {|tbl|
    with_output {|out|
      tbl.generate_csv(out)
    }
  }
end

def main_json(argv)
  require 'json'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    with_output {|out|
      out.puts JSON.pretty_generate(ary)
    }
  }
end

def main_yaml(argv)
  require 'yaml'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    with_output {|out|
      YAML.dump(ary, out)
      out.puts
    }
  }
end

def main_pp(argv)
  op_pp.parse!(argv)
  with_output {|out|
    argv.each {|filename|
      tblreader = TableReader.new(filename)
      tblreader.each {|ary|
        h = {}
        ary.each_with_index {|v, i|
          next if v.nil?
          h[tblreader.field_from_index(i)] = v
        }
        PP.pp h, out
      }
    }
  }
end

def main_grep(argv)
  op_grep.parse!(argv)
  pattern = $opt_grep_e || argv.shift
  re = Regexp.new(pattern)
  opt_v = $opt_grep_v ? true : false
  argv.each {|filename|
    with_table_stream_output {|gen|
      opt_f_index = nil
      tblreader = TableReader.new(filename)
      gen.output_header tblreader.header
      if $opt_grep_f
        opt_f_index = tblreader.index_from_field($opt_grep_f)
        if opt_f_index.nil?
          raise "field not found: #{$opt_grep_f.inspect}"
        end
      end
      tblreader.each {|ary|
        if $opt_grep_f
          found = opt_v ^ !!(re =~ ary[opt_f_index])
        else
          found = opt_v ^ !!(ary.any? {|v| re =~ v.to_s })
        end
        gen << ary if found
      }
    }
  }
end

def main_sort(argv)
  filename = argv.pop || '-'
  fs = argv.empty? ? nil : argv
  tbl = load_table(filename)
  if fs
    blk = lambda {|rec| rec.values_at(*fs) }
  else
    blk = lambda {|rec| rec.map {|k, v| v } }
  end
  tbl2 = tbl.reorder_records_by(&blk)
  with_output {|out|
    tbl2.generate_csv(out)
  }
end

def main_select(argv)
  filename = argv.pop
  fs = argv
  tblreader = TableReader.new(filename)
  header = tblreader.header
  is = []
  is = fs.map {|f| tblreader.index_from_field(f) }
  with_table_stream_output {|gen|
    gen.output_header(is.map {|i| tblreader.field_from_index(i) })
    tblreader.each {|ary|
      gen << ary.values_at(*is)
    }
  }
end

def main_rename(argv)
  if argv.length.even?
    filename = '-'
  else
    filename = argv.pop
  end
  h = {}
  argv.each_slice(2) {|k, v| h[k] = v }
  with_table_stream_output {|gen|
    tblreader = TableReader.new(filename)
    gen.output_header(tblreader.header.map {|f| h.fetch(f, f) })
    tblreader.each {|ary|
      gen << ary
    }
  }
end

def main_cat(argv)
  result = Table.new
  each_table_file(argv) {|tbl|
    fs = tbl.list_fields - result.list_fields
    fs.each {|f|
      result.define_field(f)
    }
    tbl.each {|rec| result.insert rec }
  }
  with_output {|out|
    result.generate_csv(out)
  }
end

def main_join(argv)
  result = Table.new([], [])
  each_table_file(argv) {|tbl|
    result = result.natjoin2(tbl)
  }
  with_output {|out|
    result.generate_csv(out)
  }
end

def main_count(argv)
  filename = argv.pop
  result_fields = argv.dup
  count_field = argv.pop
  fs = argv
  if fs.empty?
    n = 0
    tblreader = TableReader.new(filename)
    tblreader.each {|ary| n += 1 }
    result = Table.new([count_field], [n])
  else
    is = nil
    h = Hash.new(0)
    tblreader = TableReader.new(filename)
    is = fs.map {|f| tblreader.index_from_field(f) }
    tblreader.each {|ary| h[ary.values_at(*is)] += 1 }
    result = Table.new(result_fields)
    h.each {|k, v|
      result.insert_values result_fields, k+[v]
    }
  end
  with_output {|out|
    result.generate_csv(out)
  }
end

def each_table_file(argv)
  if argv.empty?
    yield load_table('-')
  else
    argv.each {|filename|
      tbl = load_table(filename)
      yield tbl
    }
  end
end

def load_table(filename)
  case filename
  when /\.csv\z/
    Table.load_csv(filename) {|aa| fix_table aa }
  when /\.tsv\z/
    Table.load_tsv(filename) {|aa| fix_table aa }
  else
    if filename == '-'
      content = STDIN.read
    else
      content = File.read(filename)
    end
    if /\n/ =~ content
      firstline = $`
      if /,/ =~ firstline
        return Table.parse_csv(content)
      elsif /\t/ =~ firstline
        return Table.parse_tsv(content)
      end
    else
    end
    raise "unknown file extension: #{filename.inspect}"
  end
end

class TableReader
  def initialize(filename)
    @opt_n = $opt_n
    @io = nil
    case filename
    when /\.csv\z/
      @io = File.open(filename)
      @reader = Table::CSVReader.new(@io)
    when /\.tsv\z/
      @io = File.open(filename)
      @reader = Table::TSVReader.new(@io)
    else
      if filename == '-'
        @reader = Table::CSVReader.new(STDIN)
      else
        # guess table format?
        @io = File.open(filename)
        @reader = Table::CSVReader.new(@io)
      end
    end
    @header = nil
  end

  def header
    return @header if @header
    return @header = [] if @opt_n
    while ary = @reader.shift
      if ary.all? {|elt| elt.nil? || elt == '' }
        next
      else
        @header = fix_header(ary)
        return @header
      end
    end
    @header = []
    return @header
  end

  def index_from_field(f)
    if @opt_n
      raise "numeric field start from 1: #{f.inspect}" if /\A0+\z/ =~ f
      raise "numeric field name expected: #{f.inspect}" if /\A(\d+)\z/ !~ f
      $1.to_i - 1
    else
      i = self.header.index(f)
      if i.nil?
        raise ArgumentError, "unexpected field name: #{f.inspect}"
      end
      i
    end
  end

  def field_from_index(i)
    raise ArgumentError, "negative index: #{i}" if i < 0
    if @opt_n
      "#{i+1}"
    else
      self.header
      f = @header[i]
      return f if f
      h = {}
      @header.each {|ff| h[ff] = true if /\A\(\d+\)\z/ =~ ff }
      n = 1
      while @header.length <= i
        while h[f = "(#{n})"]
          n += 1
        end
        @header << f
      end
      @header[i]
    end
  end

  def shift
    header
    @reader.shift
  end

  def each
    while ary = self.shift
      yield ary
    end
    nil
  end

  def close
    @reader.close
    @io.close
  end
end

def fix_table(aa)
  aa.shift while aa.first.all? {|elt| elt.nil? || elt == '' }
  aa.pop while aa.last.all? {|elt| elt.nil? || elt == '' }
  return aa if aa.empty?
  maxlen = aa.map {|a| a.length }.max
  if $opt_n
    aa.unshift((1..maxlen).to_a.map {|i| i.to_s })
  else
    header = aa[0]
    header << "" while header.length < maxlen
    aa[0] = fix_header(header)
  end
  aa
end

def fix_header(header)
  h = {}
  header.map {|s|
    s ||= ''
    if h[s]
      s += "(2)" if /\(\d+\)\z/ !~ s
      while h[s]
	s = s.sub(/\((\d+)\)\z/) { n = $1.to_i; "(#{n+1})" }
      end
      s
    end
    h[s] = true
    s
  }
end

def with_table_stream_output
  with_output {|out|
    Table.csv_stream_output(out) {|gen|
      def gen.output_header(header)
        self << header if !$opt_n
      end
      yield gen
    }
  }
end

def with_output
  if STDOUT.tty?
    IO.popen(ENV['PAGER'] || 'more', 'w') {|pager|
      yield pager
    }
  else
    yield STDOUT
  end
end

main ARGV
