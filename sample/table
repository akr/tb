#!/usr/bin/env ruby

require 'table'
require 'optparse'

def main(argv)
  subcommand = argv.shift
  case subcommand
  when 'help' then main_help(argv)
  when 'json' then main_json(argv)
  when 'yaml' then main_yaml(argv)
  when 'pp' then main_pp(argv)
  when 'grep' then main_grep(argv)
  when 'sort' then main_sort(argv)
  when 'select' then main_select(argv)
  when 'rename' then main_rename(argv)
  when 'cat' then main_cat(argv)
  when 'join' then main_join(argv)
  when 'count' then main_count(argv)
  when nil
    err "Usage: table subcommand args..."
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

def usage(status)
  print <<'End'
Usage:
  table json file
  table yaml file
  table pp file
  table grep [opts] REGEXP TABLE
  table sort [opts] FIELD... TABLE
  table select [opts] FIELD... TABLE
  table rename [opts] SRCFIELD DSTFIELD ... TABLE
  table cat [opts] TABLE...
  table join [opts] TABLE...
  table count [opts] FIELD... COUNT-FIELD TABLE
End
  exit status
end

def main_help(argv)
  subcommand = argv.shift
  case subcommand
  when 'grep' then puts op_grep
  when nil
    usage(true)
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

$opt_grep_e = nil
$opt_grep_f = nil
$opt_grep_v = nil
def op_grep
  op = OptionParser.new
  op.banner = 'Usage: table grep [options] REGEXP TABLE'
  op.def_option('-f FIELD') {|field| $opt_grep_f = field }
  op.def_option('-e REGEXP') {|pattern| $opt_grep_e = pattern }
  op.def_option('-v') { $opt_grep_v = true }
  op
end

def err(msg)
  STDERR.puts msg
  exit 1
end

def main_json(argv)
  require 'json'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    puts JSON.pretty_generate(ary)
  }
end

def main_yaml(argv)
  require 'yaml'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    YAML.dump(ary, STDOUT)
    puts
  }
end

def main_pp(argv)
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    pp ary
  }
end

def main_grep(argv)
  op_grep.parse!(argv)
  pattern = $opt_grep_e || argv.shift
  re = Regexp.new(pattern)
  opt_v = $opt_grep_v ? true : false
  each_table_file(argv) {|tbl|
    if $opt_grep_f
      f = $opt_grep_f
      tbl = tbl.filter {|rec| opt_v ^ !!(re =~ rec[f]) }
    else
      tbl = tbl.filter {|rec| opt_v ^ !!(rec.any? {|f, v| re =~ v.to_s }) }
    end
    tbl.generate_csv(STDOUT)
  }
end

def main_sort(argv)
  filename = argv.pop || '-'
  fs = argv.empty? ? nil : argv
  tbl = load_table(filename)
  if fs
    blk = lambda {|rec| rec.values_at(*fs) }
  else
    blk = lambda {|rec| rec.map {|k, v| v } }
  end
  tbl2 = tbl.reorder_records_by(&blk)
  tbl2.generate_csv(STDOUT)
end

def main_select(argv)
  filename = argv.pop
  fs = argv
  tbl = load_table(filename)
  tbl2 = Table.new(fs)
  tbl.each {|rec|
    tbl2.insert rec.to_h.reject {|k, v| !fs.include?(k) }
  }
  tbl2.generate_csv(STDOUT)
end

def main_rename(argv)
  if argv.length.even?
    filename = '-'
  else
    filename = argv.pop
  end
  h = {}
  argv.each_slice(2) {|k, v| h[k] = v }
  tbl = load_table(filename)
  tbl2 = tbl.rename_field(h)
  tbl2.generate_csv(STDOUT)
end

def main_cat(argv)
  result = Table.new
  each_table_file(argv) {|tbl|
    fs = tbl.list_fields - result.list_fields
    fs.each {|f|
      result.define_field(f)
    }
    tbl.each {|rec| result.insert rec }
  }
  result.generate_csv(STDOUT)
end

def main_join(argv)
  result = Table.new([], [])
  each_table_file(argv) {|tbl|
    result = result.natjoin2(tbl)
  }
  result.generate_csv(STDOUT)
end

def main_count(argv)
  input = argv.pop
  result_fields = argv.dup
  count_field = argv.pop
  fs = argv
  result = Table.new(result_fields)
  tbl = load_table(input)
  if fs.empty?
    result.insert_values [count_field], tbl.size
  else
    h = Hash.new(0)
    tbl.each {|rec|
      k = rec.values_at(*fs)
      h[k] += 1
    }
    h.each {|k, v|
      result.insert_values result_fields, k+[v]
    }
  end
  result.generate_csv(STDOUT)
end

def each_table_file(argv)
  if argv.empty?
    yield load_table('-')
  else
    argv.each {|filename|
      tbl = load_table(filename)
      yield tbl
    }
  end
end

def load_table(filename)
  case filename
  when /\.csv\z/
    Table.load_csv(filename) {|aa| fix_table aa }
  when /\.tsv\z/
    Table.load_tsv(filename) {|aa| fix_table aa }
  else
    if filename == '-'
      content = STDIN.read
    else
      content = File.read(filename)
    end
    if /\n/ =~ content
      firstline = $`
      if /,/ =~ firstline
        return Table.parse_csv(content)
      elsif /\t/ =~ firstline
        return Table.parse_tsv(content)
      end
    else
    end
    raise "unknown file extension: #{filename.inspect}"
  end
end

def fix_table(aa)
  aa.shift while aa.first.all? {|elt| elt.nil? || elt == '' }
  aa.pop while aa.last.all? {|elt| elt.nil? || elt == '' }
  return aa if aa.empty?
  maxlen = aa.map {|a| a.length }.max
  header = aa[0]
  header.map! {|s| s || '' }
  header << "" while header.length < maxlen
  h = {}
  header.map! {|s|
    if h[s]
      s += "(2)" if /\(\d+\)\z/ !~ s
      while h[s]
        s = s.sub(/\((\d+)\)\z/) { n = $1.to_i; "(#{n+1})" }
      end
      s
    end
    h[s] = true
    s
  }
  aa[0] = header
  aa
end

main ARGV
