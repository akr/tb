#!/usr/bin/env ruby
#
# Copyright (C) 2011 Tanaka Akira  <akr@fsij.org>
# 
# Redistribution and use in source and binary forms, with or without
# modification, are permitted provided that the following conditions are met:
# 
#  1. Redistributions of source code must retain the above copyright notice, this
#     list of conditions and the following disclaimer.
#  2. Redistributions in binary form must reproduce the above copyright notice,
#     this list of conditions and the following disclaimer in the documentation
#     and/or other materials provided with the distribution.
#  3. The name of the author may not be used to endorse or promote products
#     derived from this software without specific prior written permission.
# 
# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR IMPLIED
# WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO
# EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
# EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT
# OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
# INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
# CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
# IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY
# OF SUCH DAMAGE.

require 'table'
require 'optparse'
require 'enumerator'

def main(argv)
  subcommand = argv.shift
  case subcommand
  when 'help' then main_help(argv)
  when 'csv' then main_csv(argv)
  when 'json' then main_json(argv)
  when 'yaml' then main_yaml(argv)
  when 'pp' then main_pp(argv)
  when 'grep' then main_grep(argv)
  when 'sort' then main_sort(argv)
  when 'select' then main_select(argv)
  when 'rename' then main_rename(argv)
  when 'cat' then main_cat(argv)
  when 'join' then main_join(argv)
  when 'count' then main_count(argv)
  when 'sum' then main_sum(argv)
  when nil
    err "Usage: table subcommand args..."
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

def usage(status)
  print <<'End'
Usage:
  table csv [opts] TABLE
  table json [opts] TABLE
  table yaml [opts] TABLE
  table pp [opts] TABLE
  table grep [opts] REGEXP TABLE
  table sort [opts] TABLE
  table select [opts] FIELD,... TABLE
  table rename [opts] SRC,DST,... TABLE
  table cat [opts] TABLE...
  table join [opts] TABLE...
  table count [opts] TABLE
  table sum [opts] TABLE
End
  exit status
end

def main_help(argv)
  subcommand = argv.shift
  case subcommand
  when 'csv' then puts op_csv
  when 'json' then puts op_json
  when 'yaml' then puts op_yaml
  when 'pp' then puts op_pp
  when 'grep' then puts op_grep
  when 'sort' then puts op_sort
  when 'select' then puts op_select
  when 'rename' then puts op_rename
  when 'cat' then puts op_cat
  when 'join' then puts op_join
  when 'count' then puts op_count
  when 'sum' then puts op_sum
  when nil
    usage(true)
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

$opt_n = nil

def op_csv
  op = OptionParser.new
  op.banner = 'Usage: table csv [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_json
  op = OptionParser.new
  op.banner = 'Usage: table json [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_yaml
  op = OptionParser.new
  op.banner = 'Usage: table yaml [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_pp
  op = OptionParser.new
  op.banner = 'Usage: table pp [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

$opt_grep_e = nil
$opt_grep_f = nil
$opt_grep_v = nil
def op_grep
  op = OptionParser.new
  op.banner = 'Usage: table grep [opts] REGEXP TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-f FIELD') {|field| $opt_grep_f = field }
  op.def_option('-e REGEXP') {|pattern| $opt_grep_e = pattern }
  op.def_option('-v') { $opt_grep_v = true }
  op
end

$opt_sort_f = nil
def op_sort
  op = OptionParser.new
  op.banner = 'Usage: table sort [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-f FIELD,...', 'specify sort keys') {|fs| $opt_sort_f = fs }
  op
end

$opt_select_v = nil
def op_select
  op = OptionParser.new
  op.banner = 'Usage: table select [opts] FIELD,... TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-v', 'invert match') { $opt_select_v = true }
  op
end

def op_rename
  op = OptionParser.new
  op.banner = 'Usage: table rename [opts] SRC,DST,... TABLE'
  op
end

def op_cat
  op = OptionParser.new
  op.banner = 'Usage: table cat [opts] TABLE...'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

$opt_join_outer = nil
$opt_join_outer_missing = nil
def op_join
  op = OptionParser.new
  op.banner = 'Usage: table join [opts] TABLE...'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('--outer', 'outer join') { $opt_join_outer = true }
  op.def_option('--outer-missing=DEFAULT', 'missing value for outer join') {|missing|
    $opt_join_outer = true
    $opt_join_outer_missing = missing
  }
  op
end

$opt_count_f
def op_count
  op = OptionParser.new
  op.banner = 'Usage: table count [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-f KEY-FIELD1,...,COUNT-FIELD', 'zero or more key fields and one count field') {|arg| $opt_count_f = arg }
  op
end

$opt_sum_f
def op_sum
  op = OptionParser.new
  op.banner = 'Usage: table sum [opts] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-f KEY-FIELD1,...,SUM-FIELD', 'zero or more key fields and one sum field') {|arg| $opt_sum_f = arg }
  op
end

def err(msg)
  STDERR.puts msg
  exit 1
end

def main_csv(argv)
  op_csv.parse!(argv)
  each_table_file(argv) {|tbl|
    with_output {|out|
      tbl_generate_csv(tbl, out)
    }
  }
end

def main_json(argv)
  require 'json'
  op_json.parse!(argv)
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    with_output {|out|
      out.puts JSON.pretty_generate(ary)
    }
  }
end

def main_yaml(argv)
  require 'yaml'
  op_yaml.parse!(argv)
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    with_output {|out|
      YAML.dump(ary, out)
      out.puts
    }
  }
end

def main_pp(argv)
  op_pp.parse!(argv)
  with_output {|out|
    argv.each {|filename|
      tablereader_open(filename) {|tblreader|
        tblreader.each {|ary|
          h = {}
          ary.each_with_index {|v, i|
            next if v.nil?
            h[tblreader.field_from_index(i)] = v
          }
          PP.pp h, out
        }
      }
    }
  }
end

def main_grep(argv)
  op_grep.parse!(argv)
  pattern = $opt_grep_e || argv.shift
  re = Regexp.new(pattern)
  opt_v = $opt_grep_v ? true : false
  argv.each {|filename|
    with_table_stream_output {|gen|
      opt_f_index = nil
      tablereader_open(filename) {|tblreader|
        gen.output_header tblreader.header
        if $opt_grep_f
          opt_f_index = tblreader.index_from_field($opt_grep_f)
          if opt_f_index.nil?
            raise "field not found: #{$opt_grep_f.inspect}"
          end
        end
        tblreader.each {|ary|
          if $opt_grep_f
            found = opt_v ^ !!(re =~ ary[opt_f_index])
          else
            found = opt_v ^ !!(ary.any? {|v| re =~ v.to_s })
          end
          gen << ary if found
        }
      }
    }
  }
end

def main_sort(argv)
  op_sort.parse!(argv)
  filename = argv.empty? ? '-' : argv.shift
  if $opt_sort_f
    fs = split_csv_argument($opt_sort_f)
  else
    fs = nil
  end
  tbl = load_table(filename)
  if fs
    blk = lambda {|rec| rec.values_at(*fs) }
  else
    blk = lambda {|rec| rec.map {|k, v| v } }
  end
  tbl2 = tbl.reorder_records_by(&blk)
  with_output {|out|
    tbl_generate_csv(tbl2, out)
  }
end

def main_select(argv)
  op_select.parse!(argv)
  fs = split_csv_argument(argv.shift)
  filename = argv.shift || '-'
  tablereader_open(filename) {|tblreader|
    if $opt_select_v
      h = {}
      fs.each {|f| h[tblreader.index_from_field(f)] = true }
      with_table_stream_output {|gen|
        if !$opt_n
          header = []
          tblreader.header.each_with_index {|f, i|
            header << f if !h[i]
          }
          gen.output_header(header)
        end
        tblreader.each {|ary|
          values = []
          ary.each_with_index {|v, i|
            values << v if !h[i]
          }
          gen << values
        }
      }
    else
      header = tblreader.header
      is = []
      is = fs.map {|f| tblreader.index_from_field(f) }
      with_table_stream_output {|gen|
        gen.output_header(is.map {|i| tblreader.field_from_index(i) })
        tblreader.each {|ary|
          gen << ary.values_at(*is)
        }
      }
    end
  }
end

def main_rename(argv)
  op_rename.parse!(argv)
  fs = split_csv_argument(argv.shift)
  filename = argv.shift || '-'
  h = {}
  fs.each_slice(2) {|sf, df| h[sf] = df }
  with_table_stream_output {|gen|
    tablereader_open(filename) {|tblreader|
      header = tblreader.header
      h.each {|sf, df|
        unless header.include? sf
          raise "field not defined: #{sf.inspect}"
        end
      }
      renamed_header = tblreader.header.map {|f| h.fetch(f, f) }
      gen.output_header(renamed_header)
      tblreader.each {|ary|
        gen << ary
      }
    }
  }
end

def main_cat(argv)
  op_cat.parse!(argv)
  result = Table.new
  each_table_file(argv) {|tbl|
    fs = tbl.list_fields - result.list_fields
    fs.each {|f|
      result.define_field(f)
    }
    tbl.each {|rec| result.insert rec }
  }
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def main_join(argv)
  op_join.parse!(argv)
  result = Table.new([], [])
  if $opt_join_outer
    each_table_file(argv) {|tbl|
      result = result.natjoin2_outer(tbl, $opt_join_outer_missing)
    }
  else
    each_table_file(argv) {|tbl|
      result = result.natjoin2(tbl)
    }
  end
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def main_count(argv)
  op_count.parse!(argv)
  if $opt_count_f
    fs = split_csv_argument($opt_count_f)
    count_field = fs.pop
  else
    fs = []
    count_field = 'count'
  end
  filename = argv.shift || '-'
  result_fields = fs + [count_field]
  if fs.empty?
    n = 0
    tablereader_open(filename) {|tblreader|
      tblreader.each {|ary| n += 1 }
    }
    result = Table.new([count_field], [n])
  else
    is = nil
    h = Hash.new(0)
    tablereader_open(filename) {|tblreader|
      is = fs.map {|f| tblreader.index_from_field(f) }
      tblreader.each {|ary| h[ary.values_at(*is)] += 1 }
      result = Table.new(result_fields)
      h.each {|k, v|
        result.insert_values result_fields, k+[v]
      }
    }
  end
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def main_sum(argv)
  op_sum.parse!(argv)
  fs = split_csv_argument(argv.shift)
  sum_field = fs.pop
  filename = argv.shift || '-'
  result_fields = fs + [sum_field]
  is = nil
  h = Hash.new(0)
  tablereader_open(filename) {|tblreader|
    is = fs.map {|f| tblreader.index_from_field(f) }
    sum_index = tblreader.index_from_field(sum_field)
    tblreader.each {|ary|
      v = ary[sum_index]
      v = v.strip
      if !v.nil? && v != ''
	if /\A-?\d+\z/ =~ v
	  v = v.to_i
	elsif /\A-?(\d+(\.\d*)?|\.\d+)([eE][-+]?\d+)?\z/ =~ v
	  v = v.to_f
	else
	  raise "numeric value expected: #{v.inspect}"
	end
	h[ary.values_at(*is)] += v
      end
    }
  }
  result = Table.new(result_fields)
  h.each {|k, v|
    result.insert_values result_fields, k+[v]
  }
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def split_csv_argument(arg)
  Table.csv_stream_input(arg) {|ary| return ary }
  return []
end

def each_table_file(argv)
  if argv.empty?
    yield load_table('-')
  else
    argv.each {|filename|
      tbl = load_table(filename)
      yield tbl
    }
  end
end

def load_table(filename)
  tablereader_open(filename) {|tblreader|
    arys = []
    tblreader.each {|ary|
      arys << ary
    }
    header = tblreader.header
    tbl = Table.new(header)
    arys.each {|ary|
      ary << nil while ary.length < header.length
      tbl.insert_values header, ary
    }
    tbl
  }
end

def tablereader_open(filename, &b)
  Table::Reader.open(filename, {:numeric=>$opt_n}, &b)
end

def with_table_stream_output
  with_output {|out|
    Table.csv_stream_output(out) {|gen|
      def gen.output_header(header)
        self << header if !$opt_n
      end
      yield gen
    }
  }
end

def tbl_generate_csv(tbl, out)
  if $opt_n
    header = tbl.list_fields
    Table.csv_stream_output(out) {|gen|
      tbl.each {|rec|
        gen << rec.values_at(*header)
      }
    }
  else
    tbl.generate_csv(out)
  end
end

def with_output
  if STDOUT.tty?
    IO.popen(ENV['PAGER'] || 'more', 'w') {|pager|
      yield pager
    }
  else
    yield STDOUT
  end
end

main ARGV
