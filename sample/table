#!/usr/bin/env ruby

require 'table'
require 'optparse'

def main(argv)
  subcommand = argv.shift
  case subcommand
  when 'help' then main_help(argv)
  when 'json' then main_json(argv)
  when 'yaml' then main_yaml(argv)
  when 'pp' then main_pp(argv)
  when 'grep' then main_grep(argv)
  when 'sort' then main_sort(argv)
  when 'select' then main_select(argv)
  when 'cat' then main_cat(argv)
  when nil
    err "Usage: table subcommand args..."
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

def usage(status)
  print <<'End'
Usage:
  table json file
  table yaml file
  table pp file
  table grep [opts] REGEXP TABLE
  table sort [opts] FIELD... TABLE
  table select [opts] FIELD... TABLE
  table cat [opts] TABLE...
End
  exit status
end

def main_help(argv)
  subcommand = argv.shift
  case subcommand
  when 'grep' then puts op_grep
  when nil
    usage(true)
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

$opt_grep_e = nil
$opt_grep_f = nil
$opt_grep_v = nil
def op_grep
  op = OptionParser.new
  op.banner = 'Usage: table grep [options] REGEXP TABLE'
  op.def_option('-f FIELD') {|field| $opt_grep_f = field }
  op.def_option('-e REGEXP') {|pattern| $opt_grep_e = pattern }
  op.def_option('-v') { $opt_grep_v = true }
  op
end

def err(msg)
  STDERR.puts msg
  exit 1
end

def main_json(argv)
  require 'json'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    puts JSON.pretty_generate(ary)
  }
end

def main_yaml(argv)
  require 'yaml'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    YAML.dump(ary, STDOUT)
    puts
  }
end

def main_pp(argv)
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    pp ary
  }
end

def main_grep(argv)
  op_grep.parse!(argv)
  pattern = $opt_grep_e || argv.shift
  re = Regexp.new(pattern)
  opt_v = $opt_grep_v ? true : false
  each_table_file(argv) {|tbl|
    if $opt_grep_f
      f = $opt_grep_f
      tbl = tbl.filter {|rec| opt_v ^ !!(re =~ rec[f]) }
    else
      tbl = tbl.filter {|rec| opt_v ^ !!(rec.any? {|f, v| re =~ v.to_s }) }
    end
    tbl.generate_csv(STDOUT)
  }
end

def main_sort(argv)
  filename = argv.pop || '-'
  fs = argv.empty? ? nil : argv
  tbl = load_table(filename)
  if fs
    blk = lambda {|rec| rec.values_at(*fs) }
  else
    blk = lambda {|rec| rec.map {|k, v| v } }
  end
  tbl2 = Table.new(tbl.list_fields)
  recs = tbl.sort_by(&blk)
  recs.each {|rec| tbl2.insert rec }
  tbl2.generate_csv(STDOUT)
end

def main_select(argv)
  filename = argv.pop
  fs = argv
  tbl = load_table(filename)
  tbl2 = Table.new(fs)
  tbl.each {|rec|
    tbl2.insert rec.to_h.reject {|k, v| !fs.include?(k) }
  }
  tbl2.generate_csv(STDOUT)
end

def main_cat(argv)
  result = Table.new
  each_table_file(argv) {|tbl|
    fs = tbl.list_fields - result.list_fields
    fs.each {|f|
      result.define_field(f)
    }
    tbl.each {|rec| result.insert rec }
  }
  result.generate_csv(STDOUT)
end

def each_table_file(argv)
  if argv.empty?
    yield load_table('-')
  else
    argv.each {|filename|
      tbl = load_table(filename)
      yield tbl
    }
  end
end

def load_table(filename)
  case filename
  when /\.csv\z/
    Table.load_csv(filename)
  when /\.tsv\z/
    Table.load_tsv(filename)
  else
    if filename == '-'
      content = STDIN.read
    else
      content = File.read(filename)
    end
    if /\n/ =~ content
      firstline = $`
      if /,/ =~ firstline
        return Table.parse_csv(content)
      elsif /\t/ =~ firstline
        return Table.parse_tsv(content)
      end
    else
    end
    raise "unknown file extension: #{filename.inspect}"
  end
end

main ARGV
