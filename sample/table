#!/usr/bin/env ruby

require 'table'
require 'optparse'

def main(argv)
  subcommand = argv.shift
  case subcommand
  when 'help' then main_help(argv)
  when 'json' then main_json(argv)
  when 'yaml' then main_yaml(argv)
  when 'grep' then main_grep(argv)
  when 'sort' then main_sort(argv)
  when nil
    err "Usage: table subcommand args..."
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

def usage(status)
  print <<'End'
Usage:
  table json file
  table yaml file
  table grep [opts] PATTERN TABLE
  table sort [opts] TABLE
End
  exit status
end

def main_help(argv)
  subcommand = argv.shift
  case subcommand
  when 'grep' then puts op_grep
  when nil
    usage(true)
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

$opt_grep_e = nil
$opt_grep_f = nil
$opt_grep_v = nil
def op_grep
  op = OptionParser.new
  op.banner = 'Usage: table grep [options] PATTERN TABLE'
  op.def_option('-f FIELD') {|field| $opt_grep_f = field }
  op.def_option('-e PATTERN') {|pattern| $opt_grep_e = pattern }
  op.def_option('-v') { $opt_grep_v = true }
  op
end

$opt_sort_f = nil
def op_sort
  op = OptionParser.new
  op.banner = 'Usage: table sort [options] TABLE'
  op.def_option('-f FIELD') {|field| $opt_sort_f = field }
  op
end

def err(msg)
  STDERR.puts msg
  exit 1
end

def main_json(argv)
  require 'json'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    puts JSON.pretty_generate(ary)
  }
end

def main_yaml(argv)
  require 'yaml'
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    YAML.dump(ary, STDOUT)
    puts
  }
end

def main_grep(argv)
  op_grep.parse!(argv)
  pattern = $opt_grep_e || argv.shift
  re = Regexp.new(pattern)
  opt_v = $opt_grep_v ? true : false
  each_table_file(argv) {|tbl|
    if $opt_grep_f
      f = $opt_grep_f
      tbl = tbl.filter {|rec| opt_v ^ !!(re =~ rec[f]) }
    else
      tbl = tbl.filter {|rec| opt_v ^ !!(rec.any? {|f, v| re =~ v.to_s }) }
    end
    tbl.generate_csv(STDOUT)
  }
end

def main_sort(argv)
  op_sort.parse!(argv)
  each_table_file(argv) {|tbl|
    if $opt_sort_f
      blk = lambda {|rec| rec[$opt_sort_f] }
    else
      blk = lambda {|rec| rec.map {|k, v| v } }
    end
    tbl2 = Table.new(tbl.list_fields)
    recs = tbl.sort_by(&blk)
    recs.each {|rec| tbl2.insert rec }
    tbl2.generate_csv(STDOUT)
  }
end

def each_table_file(argv)
  if argv.empty?
    yield load_table('-')
  else
    argv.each {|filename|
      tbl = load_table(filename)
      yield tbl
    }
  end
end

def load_table(filename)
  case filename
  when /\.csv\z/
    Table.load_csv(filename)
  when /\.tsv\z/
    Table.load_tsv(filename)
  else
    if filename == '-'
      content = STDIN.read
    else
      content = File.read(filename)
    end
    if /\n/ =~ content
      firstline = $`
      if /,/ =~ firstline
        return Table.parse_csv(content)
      elsif /\t/ =~ firstline
        return Table.parse_tsv(content)
      end
    else
    end
    raise "unknown file extension: #{filename.inspect}"
  end
end

main ARGV
