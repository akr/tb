#!/usr/bin/env ruby

require 'table'
require 'optparse'

def main(argv)
  subcommand = argv.shift
  case subcommand
  when 'help' then main_help(argv)
  when 'csv' then main_csv(argv)
  when 'json' then main_json(argv)
  when 'yaml' then main_yaml(argv)
  when 'pp' then main_pp(argv)
  when 'grep' then main_grep(argv)
  when 'sort' then main_sort(argv)
  when 'select' then main_select(argv)
  when 'rename' then main_rename(argv)
  when 'cat' then main_cat(argv)
  when 'join' then main_join(argv)
  when 'count' then main_count(argv)
  when nil
    err "Usage: table subcommand args..."
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

def usage(status)
  print <<'End'
Usage:
  table csv [opts] TABLE
  table json [opts] TABLE
  table yaml [opts] TABLE
  table pp [opts] TABLE
  table grep [opts] REGEXP TABLE
  table sort [opts] FIELD... TABLE
  table select [opts] FIELD... TABLE
  table rename [opts] SRCFIELD DSTFIELD ... TABLE
  table cat [opts] TABLE...
  table join [opts] TABLE...
  table count [opts] FIELD... COUNT-FIELD TABLE
End
  exit status
end

def main_help(argv)
  subcommand = argv.shift
  case subcommand
  when 'grep' then puts op_grep
  when nil
    usage(true)
  else
    err "unexpected subcommand: #{subcommand.inspect}"
  end
end

$opt_n = nil

def op_csv
  op = OptionParser.new
  op.banner = 'Usage: table csv [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_json
  op = OptionParser.new
  op.banner = 'Usage: table json [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_yaml
  op = OptionParser.new
  op.banner = 'Usage: table yaml [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_pp
  op = OptionParser.new
  op.banner = 'Usage: table pp [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

$opt_grep_e = nil
$opt_grep_f = nil
$opt_grep_v = nil
def op_grep
  op = OptionParser.new
  op.banner = 'Usage: table grep [options] REGEXP TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op.def_option('-f FIELD') {|field| $opt_grep_f = field }
  op.def_option('-e REGEXP') {|pattern| $opt_grep_e = pattern }
  op.def_option('-v') { $opt_grep_v = true }
  op
end

def op_sort
  op = OptionParser.new
  op.banner = 'Usage: table sort [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_select
  op = OptionParser.new
  op.banner = 'Usage: table select [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_rename
  op = OptionParser.new
  op.banner = 'Usage: table rename [options] TABLE'
  op
end

def op_cat
  op = OptionParser.new
  op.banner = 'Usage: table cat [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_join
  op = OptionParser.new
  op.banner = 'Usage: table join [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def op_count
  op = OptionParser.new
  op.banner = 'Usage: table count [options] TABLE'
  op.def_option('-n', 'use numeric field name') { $opt_n = true }
  op
end

def err(msg)
  STDERR.puts msg
  exit 1
end

def main_csv(argv)
  op_csv.parse!(argv)
  each_table_file(argv) {|tbl|
    with_output {|out|
      tbl_generate_csv(tbl, out)
    }
  }
end

def main_json(argv)
  require 'json'
  op_json.parse!(argv)
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    with_output {|out|
      out.puts JSON.pretty_generate(ary)
    }
  }
end

def main_yaml(argv)
  require 'yaml'
  op_yaml.parse!(argv)
  each_table_file(argv) {|tbl|
    ary = tbl.map {|rec| rec.to_h }
    with_output {|out|
      YAML.dump(ary, out)
      out.puts
    }
  }
end

def main_pp(argv)
  op_pp.parse!(argv)
  with_output {|out|
    argv.each {|filename|
      tblreader = tablereader_open(filename)
      tblreader.each {|ary|
        h = {}
        ary.each_with_index {|v, i|
          next if v.nil?
          h[tblreader.field_from_index(i)] = v
        }
        PP.pp h, out
      }
    }
  }
end

def main_grep(argv)
  op_grep.parse!(argv)
  pattern = $opt_grep_e || argv.shift
  re = Regexp.new(pattern)
  opt_v = $opt_grep_v ? true : false
  argv.each {|filename|
    with_table_stream_output {|gen|
      opt_f_index = nil
      tblreader = tablereader_open(filename)
      gen.output_header tblreader.header
      if $opt_grep_f
        opt_f_index = tblreader.index_from_field($opt_grep_f)
        if opt_f_index.nil?
          raise "field not found: #{$opt_grep_f.inspect}"
        end
      end
      tblreader.each {|ary|
        if $opt_grep_f
          found = opt_v ^ !!(re =~ ary[opt_f_index])
        else
          found = opt_v ^ !!(ary.any? {|v| re =~ v.to_s })
        end
        gen << ary if found
      }
    }
  }
end

def main_sort(argv)
  op_sort.parse!(argv)
  filename = argv.pop || '-'
  fs = argv.empty? ? nil : argv
  tbl = load_table(filename)
  if fs
    blk = lambda {|rec| rec.values_at(*fs) }
  else
    blk = lambda {|rec| rec.map {|k, v| v } }
  end
  tbl2 = tbl.reorder_records_by(&blk)
  with_output {|out|
    tbl_generate_csv(tbl2, out)
  }
end

def main_select(argv)
  op_select.parse!(argv)
  filename = argv.pop
  fs = argv
  tblreader = tablereader_open(filename)
  header = tblreader.header
  is = []
  is = fs.map {|f| tblreader.index_from_field(f) }
  with_table_stream_output {|gen|
    gen.output_header(is.map {|i| tblreader.field_from_index(i) })
    tblreader.each {|ary|
      gen << ary.values_at(*is)
    }
  }
end

def main_rename(argv)
  op_rename.parse!(argv)
  if argv.length.even?
    filename = '-'
  else
    filename = argv.pop
  end
  h = {}
  argv.each_slice(2) {|sf, df| h[sf] = df }
  with_table_stream_output {|gen|
    tblreader = tablereader_open(filename)
    header = tblreader.header
    h.each {|sf, df|
      unless header.include? sf
        raise "field not defined: #{sf.inspect}"
      end
    }
    renamed_header = tblreader.header.map {|f| h.fetch(f, f) }
    gen.output_header(renamed_header)
    tblreader.each {|ary|
      gen << ary
    }
  }
end

def main_cat(argv)
  op_cat.parse!(argv)
  result = Table.new
  each_table_file(argv) {|tbl|
    fs = tbl.list_fields - result.list_fields
    fs.each {|f|
      result.define_field(f)
    }
    tbl.each {|rec| result.insert rec }
  }
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def main_join(argv)
  op_join.parse!(argv)
  result = Table.new([], [])
  each_table_file(argv) {|tbl|
    result = result.natjoin2(tbl)
  }
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def main_count(argv)
  op_count.parse!(argv)
  filename = argv.pop
  result_fields = argv.dup
  count_field = argv.pop
  fs = argv
  if fs.empty?
    n = 0
    tblreader = tablereader_open(filename)
    tblreader.each {|ary| n += 1 }
    result = Table.new([count_field], [n])
  else
    is = nil
    h = Hash.new(0)
    tblreader = tablereader_open(filename)
    is = fs.map {|f| tblreader.index_from_field(f) }
    tblreader.each {|ary| h[ary.values_at(*is)] += 1 }
    result = Table.new(result_fields)
    h.each {|k, v|
      result.insert_values result_fields, k+[v]
    }
  end
  with_output {|out|
    tbl_generate_csv(result, out)
  }
end

def each_table_file(argv)
  if argv.empty?
    yield load_table('-')
  else
    argv.each {|filename|
      tbl = load_table(filename)
      yield tbl
    }
  end
end

def load_table(filename)
  tblreader = tablereader_open(filename)
  arys = []
  tblreader.each {|ary|
    arys << ary
  }
  header = tblreader.header
  tbl = Table.new(header)
  arys.each {|ary|
    ary << nil while ary.length < header.length
    tbl.insert_values header, ary
  }
  tbl
end

def tablereader_open(filename)
  Table::Reader.open(filename, {:numeric=>$opt_n})
end

def with_table_stream_output
  with_output {|out|
    Table.csv_stream_output(out) {|gen|
      def gen.output_header(header)
        self << header if !$opt_n
      end
      yield gen
    }
  }
end

def tbl_generate_csv(tbl, out)
  if $opt_n
    header = tbl.list_fields
    Table.csv_stream_output(out) {|gen|
      tbl.each {|rec|
        gen << rec.values_at(*header)
      }
    }
  else
    tbl.generate_csv(out)
  end
end

def with_output
  if STDOUT.tty?
    IO.popen(ENV['PAGER'] || 'more', 'w') {|pager|
      yield pager
    }
  else
    yield STDOUT
  end
end

main ARGV
